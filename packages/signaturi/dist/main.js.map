{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;ACAA;ACAO,MAAM,4CAAgB;IACzB,MAAM;IACN,SAAS;IACT,SAAS;AAEb;AAEO,MAAM,4CAAe;IACxB,SAAU;QACN;YAAE,MAAM;YAAW,MAAM;QAAS;QAClC;YAAE,MAAM;YAAY,MAAM;QAAY;KACzC;IACD,SAAS;QACL;YAAE,MAAM;YAAQ,MAAM;QAAS;QAC/B;YAAE,MAAM;YAAW,MAAM;QAAU;KACtC;AACL;;;ADJO,SAAS,yCAAc,OAAqB,EAAE;IACjD,OAAO,CAAA,GAAA,uCAAiB,AAAD,EAAE,UAAU,CAAC,CAAA,GAAA,yCAAY,GAAG,CAAA,GAAA,yCAAW,GAAG;AACrE;AAGO,SAAS,0CACZ,KAAmB,EAAE,UAA4C,EACnD;IACd,mDAAmD;IACnD,kDAAkD;IAClD,2CAA2C;IAC3C,gCAAgC;IAChC,qCAAqC;IACrC,yCAAyC;IACzC,4CAA4C;IAC5C,qGAAqG;IACrG,mGAAmG;IACnG,uGAAuG;IACvG,8DAA8D;IAC9D,+FAA+F;IAC/F,yEAAyE;IACzE,0EAA0E;IAC1E,4CAA4C;IAE5C,oDAAoD;IACpD,MAAM,uBAAuB,WAAW,GAAG,CACvC,CAAA,IAAK;QACD,IAAI,MAAM,IAAI,EAAE,OAAO,IAAI;aACtB,IAAI,OAAO,MAAM,UAAU,OAAO,CAAA,GAAA,mCAAa,AAAD,EAAE;aAChD,OAAO;IAChB;IAGJ,OAAO;QACH,SAAS;QACT,YAAY;QACZ,SAAS;IACb;AACJ;;ADlDA;;;;AGAA;;AAIA,SAAS,qCACL,KAAmB,EAAE,SAAwB,EAAE,KAAa,EAC7C;IACf,IAAI,cAAc,IAAI,EAClB,OAAO;QAAE,QAAQ;IAAU;IAE/B,MAAM,UAAU,CAAA,GAAA,qCAAc,EAAE,CAAA,GAAA,yCAAa,AAAD,GAAG,CAAA,GAAA,yCAAY,AAAD,GAAG,OAAO;IACpE,MAAM,kBAAkB,MAAM,QAAQ,CAAC,MAAM,CAAC,OAAO;IACrD,IAAI,QAAQ,WAAW,OAAO,gBAAgB,WAAW,IACrD,OAAO;QAAE,QAAQ;IAAM;IAE3B,OAAO;QAAE,QAAQ;IAAO;AAC5B;AAEA,SAAS,wCAAkB,OAA0B,EAAyC;IAC1F,IAAI,OAAO;IACX,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,IAAK;QACrC,MAAM,SAAS,OAAO,CAAC,EAAE;QACzB,IAAI,OAAO,MAAM,KAAK,OAClB,OAAO;YACH,SAAS,KAAK;YACd,SAAS,CAAC,eAAe,EAAE,IAAE,EAAE,CAAC,CAAC;QACrC;aACG,IAAI,OAAO,MAAM,KAAK,QACzB,QAAQ;IAEhB;IACA,IAAI,OAAO,GACP,OAAO;QACH,SAAS,IAAI;QACb,SAAS,CAAC,SAAS,EAAE,KAAK,kBAAkB,CAAC;IACjD;SAEA,OAAO;QACH,SAAS,KAAK;QACd,SAAS,CAAC,yBAAyB,CAAC;IACxC;AAER;AAEO,SAAS,0CAAuB,cAA8B,EAAU;IAC3E,MAAM,EAAE,SAAS,MAAK,cAAE,WAAU,EAAE,GAAG;IACvC,MAAM,mBAAmB,WAAW,GAAG,CAAC,CAAC,GAAG,IAAM,qCAAe,OAAO,GAAG;IAC3E,MAAM,WAAE,QAAO,WAAE,QAAO,EAAE,GAAG,wCAAkB;IAC/C,OAAO;iBACH;iBACA;QACA,YAAY;IAChB;AACJ;","sources":["packages/signaturi/src/index.ts","packages/signaturi/src/encode.ts","packages/signaturi/src/constants.ts","packages/signaturi/src/verify.ts"],"sourcesContent":["export * from './encode'\nexport * from './verify'\n","import { Signature } from \"ethers\";\nimport { joinSignature, _TypedDataEncoder } from \"ethers/lib/utils\";\nimport { EIP712_DOMAIN, EIP712_TYPES } from \"./constants\";\nimport { EncodedMessage, InputMessage } from \"./types\";\n\n/**\n   Encode a Signaturi-compatible message into an EIP-712 accounts to sign.\n\n   Docs:\n   https://eips.ethereum.org/EIPS/eip-712\n   https://docs.ethers.org/v5/api/utils/hashing/#TypedDataEncoder\n   **/\nexport function encodeMessage(message: InputMessage) {\n    return _TypedDataEncoder.getPayload(EIP712_DOMAIN, EIP712_TYPES, message)\n}\n\n/// Creates a signaturi message that can be later verified for authenticity\nexport function createSignaturiMessage(\n    input: InputMessage, signatures: Array<Signature | string | null>\n): EncodedMessage {\n    // TODO: sanity checks (throw SignaturiEncodeError)\n    // TODO: 1/ same length of signatures and accounts\n    // TODO: 2/ at least one non-null signature\n    // TODO: 3/ signatures are valid\n    // TODO: 4/ signatures match accounts\n    // const messageHash = hashMessage(input)\n    // Recover the addresses from the signatures\n    // const recoveredAddress1 = ethers.utils.recoverAddress(messageHash, await alice.signMessage(DATA));\n    // const recoveredAddress2 = ethers.utils.recoverAddress(messageHash, await bob.signMessage(DATA));\n    // const recoveredAddress3 = ethers.utils.recoverAddress(messageHash, await charlie.signMessage(DATA));\n    // // Check the recovered address against the expected address\n    // const isValidSignature = (recoveredAddress1.toLowerCase() === alice.address.toLowerCase() &&\n    //       recoveredAddress2.toLowerCase() === bob.address.toLowerCase() &&\n    //       recoveredAddress3.toLowerCase() === charlie.address.toLowerCase()\n    //                          ) ? true : false\n\n    // serialize all signatures into into string or null\n    const serializedSignatures = signatures.map(\n        s => {\n            if (s === null) return null\n            else if (typeof s !== 'string') return joinSignature(s)\n            else return s\n        }\n    )\n\n    return {\n        message: input,\n        signatures: serializedSignatures,\n        version: '1',\n    }\n}\n","export const EIP712_DOMAIN = {\n    name: 'Signaturi',\n    version: '1',\n    chainId: 1,\n//    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC'\n}\n\nexport const EIP712_TYPES = {\n    Message : [\n        { name: 'content', type: 'string' },\n        { name: 'accounts', type: 'Account[]' },\n    ],\n    Account: [\n        { name: 'name', type: 'string' },\n        { name: 'account', type: 'address' }\n    ],\n}\n","import { verifyTypedData } from \"ethers/lib/utils\"\nimport { EIP712_DOMAIN, EIP712_TYPES } from \"./constants\"\nimport { EncodedMessage, InputMessage, Result, SignatureResult } from \"./types\"\n\nfunction checkSignature(\n    input: InputMessage, signature: string | null, index: number\n): SignatureResult {\n    if (signature === null) {\n        return { result: 'missing' }\n    }\n    const address = verifyTypedData(EIP712_DOMAIN, EIP712_TYPES, input, signature)\n    const expectedAddress = input.accounts[index].account\n    if (address.toLowerCase() !== expectedAddress.toLowerCase()) {\n        return { result: 'bad' }\n    }\n    return { result: 'good' }\n}\n\nfunction calculateValidity(results: SignatureResult[]): { isValid: boolean, message: string } {\n    let good = 0\n    for (let i = 0; i < results.length; i++) {\n        const result = results[i]\n        if (result.result === 'bad') {\n            return {\n                isValid: false,\n                message: `Bad signature #${i+1}.`,\n            }\n        } else if (result.result === 'good') {\n            good += 1\n        }\n    }\n    if (good > 0) {\n        return {\n            isValid: true,\n            message: `Success: ${good} signatures match.`,\n        }\n    } else {\n        return {\n            isValid: false,\n            message: `No good signatures found.`,\n        }\n    }\n}\n\nexport function verifySignaturiMessage(encodedMessage: EncodedMessage): Result {\n    const { message: input, signatures } = encodedMessage\n    const signatureResults = signatures.map((s, i) => checkSignature(input, s, i))\n    const { isValid, message } = calculateValidity(signatureResults)\n    return {\n        isValid,\n        message,\n        signatures: signatureResults,\n    }\n}\n"],"names":[],"version":3,"file":"main.js.map"}